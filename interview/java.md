# Java面试题

## Java的hashMap怎么做扩容的？

在 Java 的 HashMap 中，当容量达到阈值（threshold）并且发生元素插入时，会触发扩容操作。HashMap 的扩容是通过创建一个新的更大容量的数组，并将现有元素重新分布到新数组中来实现的。以下是 HashMap 扩容的步骤：

当 HashMap 中的元素数量（size）超过当前容量（capacity）乘以负载因子（load factor）时，即 size > capacity * loadFactor，就会触发扩容。

扩容时，HashMap 会将容量（capacity）翻倍，并重新计算新的阈值（threshold）。例如，如果当前容量为 n，那么新的容量将为 2n。

创建一个新的数组，其长度为新的容量。

对于原来的数组中的每个非空桶（bucket），将其中的元素重新分配到新的数组中的对应位置。这是通过重新计算元素在新数组中的索引位置来实现的。

如果原数组中的桶中存在链表或红黑树等数据结构来处理哈希冲突，那么在重新分配元素时，会尽量保持相同的顺序，以减少扩容后可能产生的新的哈希冲突。

扩容完成后，新的数组将取代原来的数组成为 HashMap 的存储结构。

扩容操作可能会导致一定的性能损耗，因为需要重新计算哈希值、重新分配元素等操作。但通过适当调整负载因子和初始容量，可以降低扩容的频率，减少性能影响。

需要注意的是，在扩容期间，HashMap 可能会出现并发访问的情况。为了解决这个问题，Java 8 引入了一种称为 "树化"（Treeify）的机制，在扩容过程中将链表转换为红黑树，提高了处理哈希冲突时的性能。

## Java的线程状态？外部怎么能影响线程状态？

在 Java 中，线程可以存在以下几种状态：

1. 新建（New）：当创建了一个 Thread 对象后，即处于新建状态。此时线程尚未启动。

2. 运行（Runnable）：调用线程的 start() 方法后，线程进入运行状态。在运行状态中，线程可能正在执行，也可能正在等待 CPU 时间片。

3. 阻塞（Blocked）：线程在某些条件下无法继续执行时，将进入阻塞状态。例如，线程在等待某个锁或等待输入/输出完成。

4. 等待（Waiting）：线程在调用 Object.wait()、Thread.join() 或者 LockSupport.park() 等方法后，会进入等待状态。等待状态的线程需要等待其他线程的唤醒才能继续执行。

5. 超时等待（Timed Waiting）：线程在调用具有超时参数的等待方法（如 Thread.sleep()、Object.wait(long)、Thread.join(long)）后会进入超时等待状态。在指定的时间内，线程会暂时停止执行。

6. 终止（Terminated）：线程执行完毕或者因异常退出后，进入终止状态。已终止的线程不可再次启动。

这些状态构成了线程的生命周期，线程可以在不同状态之间进行转换。例如，新建状态的线程通过 start() 方法切换到运行状态，运行状态的线程可能进入阻塞、等待或超时等待状态，最终可能结束执行进入终止状态。

在 Java 中，外部无法直接改变线程的状态。线程的状态是由 JVM 自身管理和控制的，只有线程自身或者其他线程通过特定的方法或操作间接影响线程的状态转换。

下面是一些可以影响线程状态的方式：

1. 启动线程：调用线程对象的 start() 方法可以将线程从新建状态切换到运行状态。

2. 线程休眠：使用 Thread.sleep() 方法可以让线程进入超时等待状态。

3. 等待和唤醒：通过调用对象的 wait()、notify() 或 notifyAll() 方法可以使线程进入等待状态，并在条件满足时被唤醒。

4. 阻塞与解除阻塞：线程在执行过程中，可能因为等待某个锁或等待输入/输出完成而进入阻塞状态。当条件满足时，阻塞状态会被解除。

5. 线程结束：线程执行完毕或者因异常退出后，进入终止状态。线程的执行体（run() 方法）执行完毕或调用 stop() 方法可以导致线程终止。

需要注意的是，直接使用 Thread 类的方法来改变其他线程的状态是不安全的，可能会引发并发问题和不可预测的结果。正确地管理线程状态需要合理地设计同步机制和协作规则，以确保线程之间的正确通信和同步。

        +-------------+
        |    New      |
        +-----+-------+
              |
              v
        +-----+-------+
        |  Runnable  |
        +-----+-------+
       /             \
      /               \
     v                 v
+-----+-------+   +-----+-------+
|   Blocked   |   |   Waiting   |
+-----+-------+   +-----+-------+
     \                 /
      \               /
       v             v
   +------+      +--------+
   | Timed |      | Terminated |
   | Waiting |      +--------+
   +--------+

新建（New）状态表示线程已创建但尚未启动。
运行（Runnable）状态表示线程正在运行或等待 CPU 时间片。
阻塞（Blocked）状态表示线程在等待获取锁或其他资源，无法继续执行。
等待（Waiting）状态表示线程调用了 wait()、notify() 或 notifyAll() 方法，并等待其他线程的通知。
超时等待（Timed Waiting）状态表示线程在等待一段时间后自动恢复执行，如调用了 sleep() 或带有超时参数的等待方法。
终止（Terminated）状态表示线程已执行完毕或因异常退出。


等待（Waiting）和超时等待（Timed Waiting）是线程在特定条件下进入的两种状态，它们之间的区别在于等待的时间限制。
等待（Waiting）状态：当一个线程调用了对象的 wait()、notify() 或 notifyAll() 方法时，线程会进入等待状态。处于等待状态的线程需要等待其他线程通过 notify() 或 notifyAll() 方法来唤醒。等待状态的线程会一直等待下去，直到被唤醒或者中断。
超时等待（Timed Waiting）状态：超时等待状态是指线程在调用具有超时参数的等待方法时，可以设置一个时间限制，在指定的时间内暂停执行。常见的超时等待方法包括 Thread.sleep() 和带有超时参数的 Object.wait(long)、Thread.join(long) 等方法。在超时等待状态下，线程会暂时停止执行，直到等待时间到期或者被唤醒。
总结来说，等待状态没有时间限制，线程需要依赖其他线程的通知来唤醒；而超时等待状态设定了一个时间限制，线程会在指定的时间内等待，如果时间到期仍未被唤醒，线程将会自动恢复执行。

