# Kafka

## 架构是什么？

Kafka 是一种高性能、分布式的消息队列系统，具有容错性和可伸缩性。它采用发布-订阅模式，允许多个生产者将消息发布到一个或多个主题（topics），多个消费者可以订阅这些主题并消费消息。

Kafka 的架构包括以下几个核心组件：

Broker（代理服务器）：Kafka 集群由多个独立的代理服务器组成，每个代理服务器即为一个 Broker，负责存储和处理消息。每个 Broker可以在不同的物理机器上运行。

Topic（主题）：消息在 Kafka 中以主题进行分类和组织。一个主题可以被划分为多个分区（partitions），每个分区在集群中的不同 Broker 上都有副本。

分区（Partition）：每个主题可以被分为多个分区，每个分区是一个有序的消息日志。分区允许在集群中水平扩展数据的存储和处理能力。

生产者（Producer）：生产者负责将消息发布到指定的主题。它将消息发送到指定主题的一个或多个分区，可以根据需求选择发送策略（如轮询、哈希等）。

消费者（Consumer）：消费者订阅一个或多个主题，并从相应的分区中拉取和消费消息。每个消费者都可以以自己的偏移量（offset）来记录其消费进度。

消费者组（Consumer Group）：多个消费者可以组成一个消费者组，共同消费一个主题的消息。每个分区只能由同一个消费者组中的一个消费者进行消费，从而实现负载均衡和容错性。

ZooKeeper：Kafka 使用 ZooKeeper 来管理集群元数据、选举领导者、协调分区分配等。ZooKeeper 保证了 Kafka 集群的高可用性和一致性。

Kafka 的架构设计使得它具有高吞吐量、低延迟、可扩展性和持久性的特点，适用于大规模数据流处理和事件驱动的应用场景。

## Partition并发是怎么样的？怎么保证有序？

在 Kafka 中，每个主题被划分为多个分区（partitions），并且每个分区可以由不同的 Broker 存储和处理。这种分区设计能够支持高度的并发性。

并发消费：由于每个分区是独立的有序消息日志，Kafka 允许多个消费者以并发的方式从不同分区中拉取和消费消息。不同的消费者可以同时处理来自不同分区的消息，实现了消费的并行性。这样可以提高整体的消费吞吐量，并且每个消费者只需要维护自己所消费分区的偏移量。

保证有序性：尽管 Kafka 具有并行消费的能力，但它也能保证每个分区内的消息顺序性。在同一个分区中，消息的顺序是有序的，即先进入分区的消息会被先消费。这是因为 Kafka 为每个消息分配一个唯一的偏移量（offset），并且按照偏移量的顺序将消息追加到分区中。消费者按照偏移量逐个获取消息，从而保证了消息的有序性。

有序写入：此外，生产者写入消息时也可以选择指定特定的分区。通过指定分区，生产者可以确保将相关的消息写入到同一个分区中，从而保持相关消息的顺序性。这在某些场景下非常重要，例如日志记录或事件溯源。

需要注意的是，跨分区的顺序保证是无法得到的，即不同分区间的消息顺序无法完全保证。如果应用程序对整体顺序有严格要求，可能需要使用只包含一个分区的主题，从而牺牲一些并行性来保证全局有序性。

## 消息接收的类型：至少一次、至多一次和过滤重复

至少一次（At Least Once）：这种接收类型确保消息最终会被消费者至少一次。当消费者拉取并处理一条消息后，在确认处理完成之前不提交偏移量。只有在消息成功处理后才提交偏移量，以防止数据丢失。如果发生故障或错误，消费者会重新从上一次提交的偏移量处开始消费，这样可以确保消息在失败情况下能够被再次消费，但可能会导致某些消息重复。

至多一次（At Most Once）：这种接收类型确保消息最多被消费者处理一次。消费者拉取并处理消息后立即提交偏移量，无论消息是否成功处理。这样可以避免消息重复消费的可能性，但也存在消息可能丢失的风险，因为在提交偏移量之前可能发生故障或错误。

过滤重复：通过使用唯一标识符或其他逻辑来判断消息的重复性，并在消费者端进行过滤。消费者在处理消息时检查消息的唯一标识符，如果已经处理过相同标识符的消息，则将其视为重复消息并进行过滤，不进行重复处理。

选择适当的消息接收类型取决于应用程序的需求和特定场景。如果数据的准确性和可靠性更为重要，可以选择至少一次的接收类型；如果对数据的实时性要求较高，可以选择至多一次的接收类型；如果能够在消费者端进行消息去重并允许一定程度的数据丢失，则可以考虑过滤重复的方式。

在 Kafka 中，可以通过以下方法来设置消息接收的类型：

消费者的 enable.auto.commit 属性：这是一个消费者配置参数，用于控制消费者是否自动提交偏移量。将该属性设置为 false 可以实现手动提交偏移量，从而控制消息接收的类型。

手动提交偏移量：如果将消费者的 enable.auto.commit 属性设置为 false，则需要在适当的时机手动提交偏移量。通过调用 Consumer.commitSync() 或 Consumer.commitAsync() 方法来提交偏移量，确保在成功处理消息之后才进行提交。这样可以实现至少一次的消息接收类型。

消息去重机制：在消费者端，可以根据消息的唯一标识符或其他逻辑进行消息去重。在处理消息时，判断消息是否已经处理过，如果是则进行过滤，避免重复处理。这种方式可以实现过滤重复的消息接收类型。

需要根据具体的应用场景和需求选择合适的设置方法。对于至多一次的消息接收类型，可以使用自动提交偏移量或设置较短的提交间隔；对于至少一次的消息接收类型，应禁用自动提交偏移量并在消息处理完成后手动提交；对于过滤重复的消息接收类型，可以在消费者端进行消息去重处理。